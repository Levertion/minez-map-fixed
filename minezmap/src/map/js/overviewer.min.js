var overviewer = {};

overviewer.map = null;

overviewer.world = {};
overviewer.currentWorld = 0;

overviewer.tileset = {};
overviewer.currentTileset = 0;
overviewer.tileLayer = null;

L.TileLayer.prototype.getTileUrl = function (tilePoint) {
	this._adjustTilePoint(tilePoint);

	var zoom = this._getZoomForUrl();
	var url = (this._url).split("/{")[0];
	var s = (this._url).split(".");
	var pathExt = s[s.length - 1];

	return overviewer.util.getTileUrl(tilePoint, zoom, url, pathExt);
};

overviewer.util = {
	/*
		Util variables
	*/
	perPixel: 0,
	centerLat: 0,
	centerLng: 0,

	/*
		Initialize Overviewer instance
	*/
	initialize: function() {
		// Clear any map elements and create a new one
		$("#map").remove();
		$("<div id='map'></div>").appendTo("#mapContainer");

		// Set up our tileset and map references
		var overrideSavedViewport = (core.util.getObjectSize(overviewer.tileset) > 0 && overviewer.world.name != overviewerConfig.worlds[overviewer.currentWorld].name);
		overviewer.world = overviewerConfig.worlds[overviewer.currentWorld];
		overviewer.tileset = overviewerConfig.worlds[overviewer.currentWorld].tilesets[overviewer.currentTileset];
		overviewer.map = L.map("map", {
			crs: L.CRS.Simple,
			attributionControl: overviewerConfig.settings.showAttribution
		});
		$("body").css("background", (core.util.getConfigValue("bgcolor").indexOf("#")==-1 ? "#" : "") + core.util.getConfigValue("bgcolor"));
		$("#map").css("background", (core.util.getConfigValue("bgcolor").indexOf("#")==-1 ? "#" : "") + core.util.getConfigValue("bgcolor"));

		// Set up variables for conversion methods
		// Ratio of Lat/Lng to 1 pixel at the highest zoom
		// This is equivalent to 0.0078125 or 1/(2^total_zoom_levels)
		overviewer.util.perPixel = 1.0 / (Math.pow(2, core.util.getConfigValue("zoomLevels")));
		// The lat and lng of the world point (0, 64, 0)
		//overviewer.util.centerLat = -209.289;
		//overviewer.util.centerLng = 192.0;
		var tileCenter = Array();
		tileCenter.x = (overviewerConfig.settings.tileSize / 2) * Math.pow(2, core.util.getConfigValue("zoomLevels"));

		// It seems like the y val is a constant ~2211 + tileCenter.x.  It probably is also dependant upon
		// the tilesize, but I can't figure that out right now.
		tileCenter.y = tileCenter.x + 2211;

		var centerLatLng = overviewer.map.unproject([tileCenter.x, tileCenter.y], core.util.getConfigValue("zoomLevels"));
		overviewer.util.centerLat = centerLatLng.lat;
		overviewer.util.centerLng = centerLatLng.lng;

		// Set up our map settings
		mapUi.loadViewport(overrideSavedViewport);

		overviewer.tileLayer = L.tileLayer(core.util.getConfigValue("path") + "/{x}." + core.util.getConfigValue("imgextension"), {
			minZoom: core.util.getConfigValue("minZoom"),
			maxZoom: core.util.getConfigValue("maxZoom"),
			tileSize: overviewerConfig.settings.tileSize,
			attribution: overviewerConfig.settings.attribution,
			continuousWorld: false,
			noWrap: true,
			reuseTiles: true,
			detectRetina: true
		}).addTo(overviewer.map);
	},

	/*
		Called when the tileset is refreshed
	*/
	refresh: function() {
		overviewer.util.initialize();
	},

	/*
		Calculate a quadtree tile path from the tile x and y

		@param Array tilePoint
		@param int zoom
		@param string url
		@param string pathExt

		@return string
	*/
	getTileUrl: function(tilePoint, zoom, url, pathExt) {
		zoom = Math.min(zoom, core.util.getConfigValue("maxZoom"));

		if (tilePoint.x < 0 || tilePoint.y < 0) {
			url += '/blank';
		} else if (zoom === 0) {
			url += '/base';
		} else {
			for (var z = zoom - 1; z >= 0; --z) {
				var x = Math.floor(tilePoint.x / Math.pow(2, z)) % 2;
				var y = Math.floor(tilePoint.y / Math.pow(2, z)) % 2;
				url += '/' + (x + 2 * y);
			}
		}
		
		url = url + '.' + pathExt + "?c=" + core.util.getConfigValue("renderTime");
		return url;
	},


	/*
		helper to get map LatLng from world coordinates takes arguments in
		X, Y, Z order (arguments are *out of order*, because within the
		function we use the axes like the rest of Minecraft Overviewer --
		with the Z and Y flipped from normal minecraft usage.)
		 
		@param int x
		@param int z
		@param int y
		 
		@return L.LatLng
	 */

	fromWorldToLatLng: function(x, y, z) {
		var lat = overviewer.util.centerLat;
		var lng = overviewer.util.centerLng;
		var perPixel = overviewer.util.perPixel;

		switch (core.util.getConfigValue("northDirection")) {
			case "upper-left":
				temp = x;
				x = z;
				z = -temp+15;
				break;
			case "lower-right":
				temp = x;
				x = -z+15;
				z = temp;
				break;
			case "lower-left":
				x = -x+15;
				z = -z+15;
				break;
		}

		// console.log("Starting world point: (" + x + ", " + y + ", " + z +")");

		// Each block on X axis adds 12px to x and subtracts 6px from y
		lng += 12 * x * perPixel;
		lat -= 6 * x * perPixel;
		// console.log("After X lat/lng calc... lat:" + lat + ", lng:" + lng);

		// Each block down along Y adds 12px to y
		lat += 12 * (y - 64) * perPixel;
		// console.log("After Y lat/lng calc... lat:" + lat + ", lng:" + lng);

		// Each block on Z axis subtracts 12px from x and subtracts 6px to y
		lng -= 12 * z * perPixel;
		lat -= 6 * z * perPixel;
		// console.log("After Z lat/lng calc... lat:" + lat + ", lng:" + lng);


		return new L.LatLng(lat, lng);
	},

	/*
		The opposite of fromWorldToLatLng
		NOTE: X, Y and Z in this function are Minecraft world definitions
		(that is, X is horizontal, Y is altitude and Z is vertical).
		
		@param float lat
		@param float lng
		
		@return Array
	*/
	fromLatLngToWorld: function(lat, lng) {
		var perPixel = overviewer.util.perPixel;

		// Initialize world (x, y, z) object to be returned
		var point = Array();
		point.x = 0;
		point.y = 64;
		point.z = 0;

		// Center the point to calculate the block shift
		lat -= overviewer.util.centerLat;
		lng -= overviewer.util.centerLng;
		// console.log("Starting lat/lng... lat:" + lat + ", lng:" + lng + ")");

		point.x += lng / (12 * perPixel);
		point.x -= lat / (6 * perPixel);
		// console.log("After X world point calc... (" + point.x + ", " + point.y + ", " + point.z + ")");

		point.z -= lng / (12 * perPixel);
		point.z -= lat / (6 * perPixel);
		// console.log("After Z world point calc... (" + point.x + ", " + point.y + ", " + point.z + ")");

		switch (core.util.getConfigValue("northDirection")) {
			case "lower-right":
				temp = point.z;
				point.z = -point.x+15;
				point.x = temp;
				break;
			case "lower-left":
				point.x = -point.x+15;
				point.z = -point.z+15;
				break;
			case "upper-left":
				temp = point.z;
				point.z = point.x;
				point.x = -temp+15;
				break;
		}

		point.x = Math.round(point.x/2);
		point.z = Math.round(point.z/2);

		return point;
	}
};